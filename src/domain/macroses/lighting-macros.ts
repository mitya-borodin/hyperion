import EventEmitter from 'node:events';

import debug from 'debug';
import cloneDeep from 'lodash.clonedeep';
import { v4 } from 'uuid';

import { ErrorType } from '../../helpers/error-type';
import { emitWirenboardMessage } from '../../infrastructure/external-resource-adapters/wirenboard/emit-wb-message';
// eslint-disable-next-line max-len
import { ControlType } from '../control-type';
import { HyperionDeviceControl } from '../hyperion-control';
import { HyperionDevice } from '../hyperion-device';

import { getControlId } from './get-control-id';
import { Macros, MacrosAccept, MacrosType } from './macros';

const logger = debug('lighting-macros');

export enum LightingLevel {
  HIGHT = 'HIGHT',
  MIDDLE = 'MIDDLE',
  LOW = 'LOW',
  ACCIDENT = 'ACCIDENT',
}

export enum LightingForce {
  ON = 'ON',
  OFF = 'OFF',
  UNSPECIFIED = 'UNSPECIFIED',
}

export type LightingMacrosPublicState = {
  force: LightingForce;
};

export type LightingMacrosPrivateState = {
  switch: 'ON' | 'OFF';
};

type LightingMacrosState = LightingMacrosPublicState & LightingMacrosPrivateState;

export type LightingMacrosSettings = {
  readonly buttons: Array<{
    readonly deviceId: string;
    readonly controlId: string;
    readonly trigger: string;
  }>;
  readonly illuminations: Array<{
    readonly deviceId: string;
    readonly controlId: string;
    readonly trigger: string;
  }>;
  readonly lightings: Array<{
    readonly deviceId: string;
    readonly controlId: string;
    readonly level: LightingLevel;
  }>;
};

type LightingMacrosNextControlState = {
  readonly lightings: Array<{
    readonly deviceId: string;
    readonly controlId: string;
    readonly value: string;
  }>;
};

type LightingMacrosParameters = {
  eventBus: EventEmitter;
  id?: string;
  name: string;
  description: string;
  labels: string[];
  settings: LightingMacrosSettings;
  state: LightingMacrosPublicState;

  readonly devices: Map<string, HyperionDevice>;
  readonly controls: Map<string, HyperionDeviceControl>;
};

export class LightingMacros implements Macros<MacrosType.LIGHTING, LightingMacrosState, LightingMacrosSettings> {
  /**
   * ! –û–±—â–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –≤—Å–µ—Ö –º–∞–∫—Ä–æ—Å–æ–≤
   */
  readonly eventBus: EventEmitter;

  /**
   * ! –î–∞–Ω–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤
   */
  private devices: Map<string, HyperionDevice>;
  private previous: Map<string, HyperionDeviceControl>;
  private controls: Map<string, HyperionDeviceControl>;

  /**
   * ! –û–±—â–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Å–µ—Ö –º–∞–∫—Ä–æ—Å–æ–≤
   */
  readonly id: string;
  readonly name: string;
  readonly description: string;
  readonly labels: string[];

  /**
   * ! –£–Ω–∏–∫–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –º–∞–∫—Ä–æ—Å–∞
   */
  readonly type: MacrosType.LIGHTING;
  readonly settings: LightingMacrosSettings;
  readonly state: LightingMacrosState;

  /**
   * ! –°–ª–µ–¥—É—é—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª–æ–≤ –Ω–∞—Ö–æ–¥—è—â–∏—Ö—Å—è –ø–æ–¥ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º
   */
  private nextControlState: LightingMacrosNextControlState;

  constructor({
    eventBus,
    devices,
    controls,
    id,
    name,
    description,
    labels,
    state,
    settings,
  }: LightingMacrosParameters) {
    /**
     * ! –û–±—â–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –≤—Å–µ—Ö –º–∞–∫—Ä–æ—Å–æ–≤
     */
    this.eventBus = eventBus;

    /**
     * ! –î–∞–Ω–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤
     */
    this.devices = cloneDeep(devices);
    this.previous = new Map();
    this.controls = cloneDeep(controls);

    /**
     * ! –û–±—â–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Å–µ—Ö –º–∞–∫—Ä–æ—Å–æ–≤
     */
    this.id = id ?? v4();
    this.name = name;
    this.description = description;
    this.labels = labels;

    /**
     * ! –£–Ω–∏–∫–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –º–∞–∫—Ä–æ—Å–∞
     */
    this.type = MacrosType.LIGHTING;
    this.settings = settings;
    this.state = {
      force: state.force,
      switch: 'OFF',
    };

    /**
     * ! –°–ª–µ–¥—É—é—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª–æ–≤ –Ω–∞—Ö–æ–¥—è—â–∏—Ö—Å—è –ø–æ–¥ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º
     */
    this.nextControlState = {
      lightings: [],
    };

    /**
     * ! –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ç–∏–ø–∞–º.
     */
    for (const setting of this.settings.buttons) {
      const button = this.controls.get(getControlId(setting));

      if (!button) {
        logger('Button control not found üö®');
        logger(JSON.stringify({ setting }, null, 2));

        throw new Error(ErrorType.INVALID_ARGUMENTS);
      }

      if (button.type !== ControlType.SWITCH) {
        logger('Button control is not SWITCH üö®');
        logger(JSON.stringify({ setting }, null, 2));

        throw new Error(ErrorType.INVALID_ARGUMENTS);
      }
    }

    for (const setting of this.settings.illuminations) {
      const illumination = this.controls.get(getControlId(setting));

      if (!illumination) {
        logger('Illumination control not found üö®');
        logger(JSON.stringify({ setting }, null, 2));

        throw new Error(ErrorType.INVALID_ARGUMENTS);
      }

      if (illumination.type !== ControlType.ILLUMINATION) {
        logger('Illumination control is not ILLUMINATION üö®');
        logger(JSON.stringify({ setting }, null, 2));

        throw new Error(ErrorType.INVALID_ARGUMENTS);
      }
    }

    for (const setting of this.settings.lightings) {
      const lighting = this.controls.get(getControlId(setting));

      if (!lighting) {
        logger('Illumination control not found üö®');
        logger(JSON.stringify({ setting }, null, 2));

        throw new Error(ErrorType.INVALID_ARGUMENTS);
      }

      if (lighting.type !== ControlType.SWITCH) {
        logger('Illumination control is not SWITCH üö®');
        logger(JSON.stringify({ setting }, null, 2));

        throw new Error(ErrorType.INVALID_ARGUMENTS);
      }
    }
  }

  toJS = () => {
    return cloneDeep({
      id: this.id,
      name: this.name,
      description: this.description,
      type: this.type,
      labels: this.labels,
      settings: this.settings,
      state: this.state,
    });
  };

  setState = (state: LightingMacrosPublicState): void => {
    switch (state.force) {
      case LightingForce.ON: {
        this.state.force = LightingForce.ON;

        break;
      }
      case LightingForce.OFF: {
        this.state.force = LightingForce.OFF;

        break;
      }
      case LightingForce.UNSPECIFIED: {
        this.state.force = LightingForce.UNSPECIFIED;

        break;
      }
      default: {
        logger('An incorrect state was received üö®');
        logger(JSON.stringify({ state }, null, 2));

        return;
      }
    }

    this.execute();
  };

  accept = ({ devices, previous, controls, device }: MacrosAccept): void => {
    this.devices = devices;
    this.previous = previous;
    this.controls = controls;

    if (this.isNeedToExecute(device)) {
      this.execute();
    }
  };

  private isNeedToExecute = (device: HyperionDevice) => {
    for (const control of device.controls) {
      const button = this.settings.buttons.find(
        (button) => button.deviceId === device.id && button.controlId === control.id,
      );
      const lighting = this.settings.lightings.find(
        (lighting) => lighting.deviceId === device.id && lighting.controlId === control.id,
      );

      if (button || lighting) {
        return true;
      }
    }

    return false;
  };

  private hasButtonPress = (): boolean => {
    return this.settings.buttons.some((button) => {
      const id = getControlId({ deviceId: button.deviceId, controlId: button.controlId });

      const previous = this.previous.get(id);
      const control = this.controls.get(id);

      if (!previous || !control) {
        return false;
      }

      if (previous.value !== control.value && control.value === '1') {
        return true;
      }

      return false;
    });
  };

  private execute = () => {
    logger('Execute lighting macros üöÄ üë∑‚Äç‚ôÇÔ∏è ‚è≠Ô∏è');

    /**
     * ! FORCE ON LOGIC
     */
    if (this.state.force !== 'UNSPECIFIED') {
      let value = '0';

      if (this.state.force === 'ON') {
        this.state.switch = 'ON';

        value = '1';
      }

      if (this.state.force === 'OFF') {
        this.state.switch = 'OFF';

        value = '0';
      }

      logger('The forced state was determined ü´° üò°');
      logger(JSON.stringify({ state: this.state, value }, null, 2));

      this.computeNextControlState(value);
      this.sendMessages();

      return;
    }

    /**
     * ! BUTTON PRESS LOGIC
     */
    if (this.hasButtonPress()) {
      logger('Button was pressed üßØ');
      logger(JSON.stringify({ state: this.state }, null, 2));

      /**
       * ! –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å this.settings.illuminations, –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è –ø–æ–¥—Ö–æ–¥—è—â–µ–π –∑–æ–Ω—ã —Å–≤–µ—Ç–∞:
       * ! –æ—Å–Ω–æ–≤–Ω–æ–π, —Å—Ä–µ–¥–Ω–∏–π, –Ω–∏–∑–∫–∏–π.
       */
      if (this.state.switch === 'ON') {
        this.state.switch = 'OFF';

        this.computeNextControlState('0');

        logger('Next state will be üßØ');
        logger(JSON.stringify({ nextState: this.state, nextControlState: this.nextControlState }, null, 2));

        this.sendMessages();

        return;
      }

      if (this.state.switch === 'OFF') {
        this.state.switch = 'ON';

        this.computeNextControlState('1');

        logger('Next state will be üßØ');
        logger(JSON.stringify({ nextState: this.state, nextControlState: this.nextControlState }, null, 2));

        this.sendMessages();

        return;
      }
    }

    /**
     * ! CHECK OUTPUT CONTROL STATE
     */
    this.checkOutputControlState();
  };

  private checkOutputControlState = () => {
    const isOn = this.settings.lightings.every((lighting) => {
      const id = getControlId({ deviceId: lighting.deviceId, controlId: lighting.controlId });

      const control = this.controls.get(id);

      if (control) {
        return control.value === '1';
      }

      return false;
    });

    const nextState = isOn ? 'ON' : 'OFF';

    if (this.state.switch !== nextState) {
      this.state.switch = isOn ? 'ON' : 'OFF';

      logger('The internal state has been changed because all managed controls have changed state üë∑‚Äç‚ôÇÔ∏è üçã üßØ');
      logger(JSON.stringify({ state: this.state }, null, 2));
    }
  };

  private computeNextControlState = (value: string) => {
    const nextControlState: LightingMacrosNextControlState = {
      lightings: [],
    };

    for (const { deviceId, controlId } of this.settings.lightings) {
      const type = ControlType.SWITCH;

      const control = this.controls.get(getControlId({ deviceId, controlId }));

      if (!control) {
        logger('The control specified in the settings was not found üö®');
        logger(JSON.stringify({ deviceId, controlId, controls: [...this.controls.values()] }, null, 2));

        continue;
      }

      if (control.type !== type) {
        logger('The type of control does not match the settings üö®');
        logger(JSON.stringify({ deviceId, controlId, type, control, controls: [...this.controls.values()] }, null, 2));

        continue;
      }

      if (!control.topic) {
        logger('The control object does not contain a topic for sending messages üö®');
        logger(JSON.stringify({ deviceId, controlId, type, control, controls: [...this.controls.values()] }, null, 2));

        continue;
      }

      /**
       * ! –ï—Å–ª–∏ –Ω–µ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –Ω–∞ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç—å value, —Ç–æ –∫–æ–≥–¥–∞ WB –≤–µ—Ä–Ω–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
       * ! –º—ã —Å–Ω–æ–≤–∞ –æ—Ç–ø—Ä–∞–≤–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ, –∏ WB –Ω–∞–º –µ–≥–æ –≤–µ—Ä–Ω–µ—Ç –∫–∞–∫ –Ω–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ, —Ç–æ –º—ã –ø–æ–ø–∞–¥–µ–º –≤ —Ä–µ–∫—É—Ä—Å–∏—é.
       *
       * ! –ù–µ –∏–∑–≤–µ—Å—Ç–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –ª–∏ –Ω–∞ —ç—Ç–æ WB, —Å–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ –¥–∞, –Ω–æ –Ω–∞–º –Ω–µ –ø–æ–º–µ—à–∞–µ—Ç –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —ç—Ç–æ —Å–∞–º–∏–º.
       */
      if (control.value !== value) {
        nextControlState.lightings.push({
          deviceId,
          controlId,
          value,
        });
      }
    }

    this.nextControlState = nextControlState;
  };

  private sendMessages = () => {
    for (const lighting of this.nextControlState.lightings) {
      const hyperionDevice = this.devices.get(lighting.deviceId);
      const hyperionControl = this.controls.get(
        getControlId({ deviceId: lighting.deviceId, controlId: lighting.controlId }),
      );

      if (!hyperionDevice || !hyperionControl || !hyperionControl.topic) {
        logger('Incorrect data for sending messages üö®');
        logger(JSON.stringify({ lighting, hyperionDevice, hyperionControl, topic: hyperionControl?.topic }, null, 2));

        continue;
      }

      /**
       * ! –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –∏–∑ –º–∞–∫—Ä–æ—Å–∞, –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –≥–æ–Ω–∫–µ —Å–æ—Å—Ç–æ—è–Ω–∏–π.
       * ! –í–æ–∑–º–æ–∂–Ω–æ –≤ –¥–∞–ª—å–Ω–µ–π—à–µ–º, –º—ã —Å–¥–µ–ª–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω—É—é —Å–ª—É–∂–±—É –∫–æ—Ç–æ—Ä–∞—è –±—É–¥–µ—Ç –≤—ã–±–∏—Ä–∞—Ç—å –≤ –∫–∞–∫–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
       * ! –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–µ—Ö –∏–ª–∏ –∏–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –º–∞–∫—Ä–æ—Å–æ–≤.
       */
      const { topic } = hyperionControl;
      const message = lighting.value;

      logger('A message will be sent to the WB üöÄ üë∑‚Äç‚ôÇÔ∏è üçü');
      logger(JSON.stringify({ topic, message }, null, 2));

      emitWirenboardMessage({ eventBus: this.eventBus, topic, message });
    }
  };
}
