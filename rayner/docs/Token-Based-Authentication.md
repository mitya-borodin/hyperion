# Про токены, JSON Web Tokens (JWT), аутентификацию и авторизацию. Token-Based Authentication

`Last major update: 25.08.2020`

- Что такое авторизация/аутентификация
- Где хранить токены
- Как ставить куки ?
- Процесс логина
- Процесс рефреш токенов
- Кража токенов/Механизм контроля токенов
- Зачем все это ? JWT vs Cookie sessions

## Основа

**Аутентификация(authentication, от греч. αὐθεντικός [authentikos] – реальный, подлинный; от αὐθέντης [authentes] – автор)** - это процесс проверки учётных данных пользователя (логин/пароль). Проверка подлинности пользователя путём сравнения введённого им логина/пароля с данными сохранёнными в базе данных.

**Авторизация(authorization — разрешение, уполномочивание)** - это проверка прав пользователя на доступ к определенным ресурсам.

Например, после аутентификации юзер **_sasha_** получает право обращаться и получать от ресурса **"super.com/vip"** некие данные. Во время обращения юзера _**sasha**_ к ресурсу **vip** система авторизации проверит имеет ли право юзер обращаться к этому ресурсу (проще говоря переходить по неким разрешенным ссылкам)

1. Юзер c емайлом **_sasha_gmail.com_** успешно прошел аутентификацию
2. Сервер посмотрел в БД какая роль у юзера
3. Сервер сгенерил юзеру токен с указанной ролью
4. Юзер заходит на некий ресурс используя полученный токен
5. Сервер смотрит на права(роль) юзера в токене и соответственно пропускает или отсекает запрос

Собственно п.5 и есть процесс **авторизации**.

_Дабы не путаться с понятиями **Authentication/Authorization** можно использовать псевдонимы **checkPassword/checkAccess**(я так сделал в своей API)_

**JSON Web Token (JWT)** — содержит три блока, разделенных точками: заголовок(**header**), набор полей (**payload**) и **сигнатуру**. Первые два блока представлены в JSON-формате и дополнительно закодированы в формат base64. Набор полей содержит произвольные пары имя/значения, притом стандарт JWT определяет несколько зарезервированных имен (iss, aud, exp и другие). Сигнатура может генерироваться при помощи и симметричных алгоритмов шифрования, и асимметричных. Кроме того, существует отдельный стандарт, отписывающий формат зашифрованного JWT-токена.

Пример подписанного JWT токена (после декодирования 1 и 2 блоков):

```
{ alg: "HS256", typ: "JWT" }.{ iss: "auth.myservice.com", aud: "myservice.com", exp: 1435937883, userName: "John Smith", userRole: "Admin" }.S9Zs/8/uEGGTVVtLggFTizCsMtwOJnRhjaQ2BMUQhcY
```

**Токены** предоставляют собой средство **авторизации** для каждого запроса от клиента к серверу. Токены(и соответственно сигнатура токена) генерируются на сервере основываясь на секретном ключе(который хранится на сервере) и **payload'e**. Токен в итоге хранится на клиенте и используется при необходимости **авторизации** какого-либо запроса. Такое решение отлично подходит при разработке SPA.

При попытке хакером подменить данные в **header'ре** или **payload'е**, токен станет не валидным, поскольку сигнатура не будет соответствовать изначальным значениям. А возможность сгенерировать новую сигнатуру у хакера отсутствует, поскольку секретный ключ для зашифровки лежит на сервере.

**access token** - используется для **авторизации запросов** и хранения дополнительной информации о пользователе (аля **user_id**, **user_role** или еще что либо, эту информацию также называет **payload**). Все поля в **payload** это свободный набор полей необходимый для реализации вашей частной бизнес логики. То бишь **user_id** и **user_role** не являются требованием и представляют собой исключительно частный случай. **Сам токен храним не в localStorage как это обычно делают, а в памяти клиентского приложения.**

**refresh token** - выдается сервером по результам успешной аутентификации и используется для получения новой пары **access/refresh** токенов. **Храним исключительно в httpOnly куке**.

Каждый токен имеет свой срок жизни, например **access**: 30 мин, **refresh**: 60 дней

**Поскольку токены(а данном случае access) это не зашифрованная информация крайне не рекомендуется хранить в них какую либо `sensitive data` (passwords, payment credentials, etc...)**

**Роль рефреш токенов и зачем их хранить в БД.** Рефреш на сервере хранится для учета доступа и инвалидации краденых токенов. Таким образом сервер наверняка знает о клиентах которым стоит доверять(кому позволено авторизоваться). Если не хранить рефреш токен в БД то велика вероятность того что токены будут бесконтрольно гулять по рукам злоумышленников. Для отслеживания которых нам придется заводить черный список и периодически чистить его от просроченных. В место этого мы храним лимитированный список белых токенов для каждого юзера отдельно и в случае кражи у нас уже есть механизм противодействия(описано ниже).

## Как ставить куки ?

Для того что бы `refreshToken` кука была успешно уставленна и отправлена браузером, адреса эндпоинтов аутентификации(`/api/auth/login`, `/api/auth/refresh-tokens`, `/api/auth/logout`) должны располагася в доменном пространстве сайта. Тоесть для домена `super.com` на сервере ставим куку с такими опциями:

```
{
    domain: '.super.com',
    path: '/api/auth'
}
```

Таким образом кука установится в браузер и прийдет на все эндпоинты по адресу `super.com/api/auth/<any-path>`

Если у нас монолит и за аутентификацию отвечает один и тот-же API, тут проблем не должно быть. Но если за аутентификацию отвечает отдельный микросервис, прячем его средствами `nginx` по выше указанному пути (`super.com/api/auth`).

```
# пример настройки nginx конфига(только основые настройки)
server {
    listen 80;
    server_name super.com;
    # SPA/Front-end
    location / {
        try_files $uri /index.html;
        root /var/www/frontend/dist;
        index index.html;
    }
    # Main API
    location /api {
        proxy_pass http://111.111.111.111:7000;
    }
    # Auth API
    location /api/auth {
        proxy_redirect http://222.222.222.222:7000   /auth/;
        proxy_pass http://222.222.222.222:7000;
    }
}
```

## Логин, создание сессии/токенов (api/auth/login)

1. Пользователь логинится в приложении, передавая логин/пароль и **fingerprint** браузера (ну или некий иной уникальный идентификатор устройства если это не браузер)
2. Сервер проверят подлинность логина/пароля
3. В случае удачи создает и записывает сессию в БД `{ userId: uuid, refreshToken: uuid, expiresIn: int, fingerprint: string, ... }` (схема таблицы ниже)
4. Создает **access token**
5. Отправляет клиенту **access и refresh token uuid** (взятый из выше созданной сессии)

```
Set-Cookie: refreshToken='c84f18a2-c6c7-4850-be15-93f9cbaef3b3'; HttpOnly // для браузера
{
  body: {
    accessToken: 'eyJhbGciOiJIUzUxMiIsI...',
    refreshToken: 'c84f18a2-c6c7-4850-be15-93f9cbaef3b3' // для мобильных приложений
  }
}
```

6. Клиент сохраняет токены(**access** в памяти приложения, **refresh** сетится как кука автоматом)

На что нужно обратить внимание при установке **refresh** куки:

- `maxAge` куки ставим равную `expiresIn` из выше созданной сессии
- В `path` ставим корневой роут `auth` контроллера (`/api/auth`) это важно, таким образом токен получат только те хендлеры которым он нужен(`/api/auth/logout` и `/api/auth/rerfesh-tokens`), остальные обойдутся(нечего зря почём отправлять **sensitive data**).

**Стоит заметить, что процесс добавления сессии в таблицу должен имеет свои меры безопасности.** При добавлении стоит проверять сколько рефреш-сессий всего есть у юзера и, если их слишком много или юзер конектится одновременно из нескольких подсетей, стоит предпринять меры. Имплементируя данную проверку, я проверяю только что бы юзер имел максимум до 5 одновременных рефреш-сессий максимум, и при попытке установить следующую удаляю предыдущие. Все остальные проверки на ваше усмотрение в зависимости от задачи.

Таким образом если юзер залогинился на пяти устройствах, рефреш токены будут постоянно обновляться и все счастливы. Но если с аккаунтом юзера начнут производить подозрительные действия(попытаются залогинится более чем на 5'ти устройствах) система сбросит все сессии(рефреш токены) кроме последней.

Перед каждым запросом клиент предварительно проверяет время жизни **access token'а** (да берем `expiresIn` прямо из JWT в клиентском приложении) и если оно истекло шлет запрос на обновление токенов. Для большей уверенности можем обновлять токены на несколько секунд раньше. То есть кейс когда API получит истекший **access** токен практически исключен.

Что такое **fingerprint** ? Это инструмент отслеживания браузера вне зависимости от желания пользователя быть идентифицированным. Это хеш сгенерированный js'ом на базе неких уникальных параметров/компонентов браузера. Преимущество **fingerprint'a** в том что он нигде персистентно не хранится и генерируется только в момент логина и рефреша.

- Библиотека для хеширования: <https://github.com/Valve/fingerprintjs2>
- Более подробно: <https://player.vimeo.com/video/151208427>
- Пример ф-ции получения такого хеша: <https://gist.github.com/zmts/b26ba9a61aa0b93126fc6979e7338ca3>

В случае если клиент не браузер, а мобильное приложение, в качестве **fingerprint** используем любую уникальную строку(тот же `uuid`) персистентно хранящуюся на устройстве.

## Рефреш токенов (api/auth/refresh-tokens)

Для использования возможности аутентификации на более чем одном девайсе необходимо хранить все рефреш токены по каждому юзеру. Я храню это список в PostgreSQL таблице(а надо бы в Redis'е). В процессе каждого логина создается запись с IP/Fingerprint и другой мета информацией, так званая **рефреш-сессия**.

```
CREATE TABLE refreshSessions (
    "id" SERIAL PRIMARY KEY,
    "userId" uuid REFERENCES users(id) ON DELETE CASCADE,
    "refreshToken" uuid NOT NULL,
    "ua" character varying(200) NOT NULL, /* user-agent */
    "fingerprint" character varying(200) NOT NULL,
    "ip" character varying(15) NOT NULL,
    "expiresIn" bigint NOT NULL,
    "createdAt" timestamp with time zone NOT NULL DEFAULT now()
);
```

1. Клиент(фронтенд) проверяет перед запросом не истекло ли время жизни **access token'на**
2. Если истекло клиент делает запрос на `POST auth/refresh-tokens` `{ fingerprint: string }` в `body` и соответственно `refreshToken` куку.
3. Сервер получает запись рефреш-сессии по UUID'у рефреш токена
4. Сохраняет текущую рефреш-сессию в переменную и удаляет ее из таблицы
5. Проверяет текущую рефреш-сессию:
   1. Не истекло ли время жизни
   2. На соответствие старого **fingerprint'a** полученного из текущей рефреш-сессии с новым полученным из тела запроса
6. В случае негативного результата бросает ошибку `TOKEN_EXPIRED`/`INVALID_REFRESH_SESSION`
7. В случае успеха создает новую рефреш-сессию и записывает ее в БД
8. Создает **access token**
9. Отправляет клиенту **access и refresh token uuid** (взятый из выше созданной рефреш-сессии)

```
Set-Cookie: refreshToken='c84f18a2-c6c7-4850-be15-93f9cbaef3b3'; HttpOnly // для браузера
{
  body: {
    accessToken: 'eyJhbGciOiJIUzUxMiIsI...',
    refreshToken: 'c84f18a2-c6c7-4850-be15-93f9cbaef3b3' // для мобильных приложений
  }
}
```

_Tip:_ Для отправки запроса с куками для `axios` есть опция `{ withCredentials: true }`

## Ключевой момент

В момент рефреша то есть обновления **access token'a** обновляются **ОБА** токена. Но как же **refresh token** может сам себя обновить, он ведь создается только после успешной аутентификации ? **refresh token** в момент рефреша сравнивает себя с тем **refresh token'ом** который лежит в БД и вслучае успеха, а также если у него не истек срок, система рефрешит токены.

Вопрос зачем **refresh token'y** срок жизни, если он обновляется каждый раз при обновлении **access token'a** ? Это сделано на случай, если юзер будет в офлайне более 60 дней, тогда придется заново вбить логин/пароль.

## В случае кражи access токена и refresh куки

1. Хакер воспользовался **access token'ом**
2. Закончилось время жизни **access token'на**
3. **Клиент хакера** отправляет **refresh token** и **fingerprint**
4. Сервер смотрит **fingerprint** хакера
5. Сервер не находит **fingerprint** хакера в рефреш-сессии и удаляет ее из БД
6. Сервер логирует попытку несанкционированного обновления токенов
7. Сервер перенаправляет хакера на станицу логина. Хакер идет лесом
8. Юзер пробует зайти на сервер >> обнаруживается что **refresh token** отсутствует
9. Сервер перенаправляет юзера на форму аутентификации
10. Юзер вводит логин/пароль

## В случае кражи access токена, refresh куки и fingerprint'а

Стащить все авторизационные данные это не из легких задач, но все же допустим этот кейс как крайний и наиболее неудобный с точки зрения UX (без примера в кодовой базе `supra-api-nodejs`).

Предложу несколько вариантов решения данной проблемы:

- Хранить IP или Subnet залогиненного клиента

1. Хакер воспользовался **access token'ом**
2. Закончилось время жизни **access token'на**
3. **Хакер** отправляет **refresh** куку и **fingerprint**
4. Сервер проверяет IP **хакера**, **хакер** идет лесом

_UX минус: нужно логинится с каждого нового IP._

- Удалять все сессии в случае если **refresh** токен не найден

1. Хакер воспользовался **access token'ом**
2. Закончилось время жизни **access token'на**
3. **Хакер** отправляет **refresh** куку и **fingerprint**
4. На сервере создается новый **refresh** токен ("от хакера")
5. Хакер получает новую пару токенов
6. Юзер пробует отправить запрос на сервер >> обнаруживается что **refresh** токен не валиден
7. Сервер удаляет все сессии юзера, в последствии чего хакер больше не сможет обновлять **access** токен
8. Сервер создает новую сессию для пользователя

_UX минус: в каждом случае когда сервер не будет находить рефреш токен - будут сбрасиватся все сессии юзера на всех устройствах._

## Зачем все это ? JWT vs Cookie sessions

Зачем этот весь геморой ? Почему не юзать старые добрые cookie sessions ? Чем не угодили куки ?

- Куки подвержены CSRF: <https://habr.com/ru/company/oleg-bunin/blog/412855> <https://www.youtube.com/watch?v=x5AuK_IbJlg>
- Нативыным приложениям для сматфонов удобнее работать с токенами. Да есть хаки для работы с куки, но это не нативная поддержка
- Куки в микросерисной архитектуре использовать не вариант. Напомню зачастую микросервисы раскиданы на разных доменах, а куки не поддерживают кросc-доменные запросы
- В микросерисной архитектуре JWT позволяет каждому сервису независимо от сервера авторизации верифицировать `access` токен (через публичный ключ)
- При использовании cookie sessions программист зачастую надеется на то, что предоставил фреймворк и оставляет как есть
- При использовании jwt мы видим проблему с безопасностью и стараемся предусмотреть механизмы контроля в случае каржи авторизационных данных. При использовании cookie сессий программист зачастую даже не задумывается что сессия может быть скомпрометирована
- **На каждом запросе** использование JWT избавляет бекенд от одного запроса в БД(или кеш) за данными пользователя(`userId`, `email`, etc.)

## В итоге

- **access** токены храним исключительно в памяти клиентского приложения. Не в глобально доступной переменной аля `window.accessToken` а в **замыкании**
- **refresh** токен храним исключительно в **httpOnly** куке
- Механизмы контроля при угоне **sensitive data** в наличии
- Взяли лучшее из обеих технологий, максимально обезопасились от CSRF/XSS
- Добавьте в компанию ко всему CSP заголовки и SameSite=Strict флаг для кук и ждите прихода злодеев

p.s. Каждой задаче свой подход. Юзайте в небольших/средних монолитах `cookie sessions` и не парьтесь. Ну или на ваш вкус :)

---

### Имплементация

**Front-end:**

- <https://github.com/zmts/beauty-vuejs-boilerplate/blob/master/src/services/http.init.js>
- <https://github.com/zmts/beauty-vuejs-boilerplate/blob/master/src/services/auth.service.js>

**Back-end:**

- <https://github.com/zmts/supra-api-nodejs/tree/master/modules/auth>

### Info

- <https://www.youtube.com/playlist?list=PLvTBThJr861y60LQrUGpJNPu3Nt2EeQsP>
- <https://habrahabr.ru/company/Voximplant/blog/323160/>
- <https://tools.ietf.org/html/rfc6749>
- <https://www.digitalocean.com/community/tutorials/oauth-2-ru>
- <https://jwt.io/introduction/>
- <https://auth0.com/blog/using-json-web-tokens-as-api-keys/>
- <https://auth0.com/blog/cookies-vs-tokens-definitive-guide/>
- <https://auth0.com/blog/ten-things-you-should-know-about-tokens-and-cookies/>
- <https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/>
- <https://habr.com/company/dataart/blog/262817/>
- <https://habr.com/post/340146/>
- <https://habr.com/company/mailru/blog/115163/>
- <https://scotch.io/tutorials/authenticate-a-node-js-api-with-json-web-tokens>
- <https://egghead.io/courses/json-web-token-jwt-authentication-with-node-js>
- <https://www.digitalocean.com/community/tutorials/oauth-2-ru>
- <https://github.com/shieldfy/API-Security-Checklist/blob/master/README-ru.md>
- <https://www.youtube.com/watch?v=Ngh3KZcGNaU>
- <https://www.youtube.com/watch?v=R0-eoLp871s>
- <https://www.youtube.com/watch?v=u9hn3s2kUrg>
- <https://ain.ua/2020/02/29/adtech-bez-cookies/>
- <https://habr.com/ru/post/492830> (cookies SameSite)

### And why JWT is bad

- <http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/>
- <http://cryto.net/~joepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/>
- <https://medium.com/@cjainn/anatomy-of-a-jwt-token-part-1-8f7616113c14>
- <https://medium.com/@cjainn/anatomy-of-a-jwt-token-part-2-c12888abc1a2>
- <https://scotch.io/bar-talk/why-jwts-suck-as-session-tokens>
- <https://t.me/why_jwt_is_bad>

---

_Комментарии периодически подчищаются_
